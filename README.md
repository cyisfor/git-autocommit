Disclaimer: this is a terrible idea.

Ever spend all day making a million changes, then want to find that one thing you tried, but deleted because you didn’t think it would be needed? Gosh if only there were revision control software to handle that. Well, see the problem is people demand that you only make “meaningful” commits. You changed a file to fix an overflow error while changing another file to add an environment variable, and added a file you forgot to the Makefile? Well then, you better be ready to type an essay, because your commit message must be “fixed an overflow error in a/foo.c added an environment variable to p/d/q.c and added README.md to the Makefile.” Otherwise be ready to dance around with `git add` and leave three commits one for each change, hoping and praying that two changes don’t both occur in the same hunk. Never mind that git already records all that information automatically, making all your effort to write those messages completely useless, if you can’t think of a good meaningful commit message, then how dare you commit any changes!

So, this thing says pretty much “Forget commit messages. Preserving change history’s more important.”

Set up your editor (see gitcommit.el) to call “client” every time you finish saving a file, setting the “file” environment variable to the path. It’ll fork off “server” if necessary, and server will sit there waiting around for enough changes to accumulate in that repository. If it waits long enough, it commits anyway.

It makes an automatic commit message that’s not really useful since you can get all those stats in other ways, but just using the message “COMMIT MESSAGE ARE DUMB HURR” seemed too visionary for our dark times. If you want to write a meaningful “milestone” message yourself, you’ll probably have to say `git commit -a --allow-empty` when you perform your manual commit, because git thinks commits without files are evil or something. Otherwise, to get a meaningful idea of what these micro-commits mean, just do `git log -p`

Oh, and if some project manager starts whining at you about not leaving meaningful commit messages, check “git log” to find the earliest commit that has “auto” in it, in the case of this project it’ll be `commit=13d9fc9d4316832382d3464b084555f34dab775b`. now do `git rebase -i $commit~1` with the ~1 meaning one commit before. It’ll pop up an editor with a bunch of lines, and every one that says “pick” next to an “auto” commit message, replace “pick” with “reword.” Save and quit, and git will replay each change, popping up an editor to let you rewrite the commit message. When it pops up an editor, go to the directory in a different terminal and run `git show`. That will show you what changes were made then, and you can figure out something random to say that will make the project managers happy. (In my case, it was “initial delayed commit framework”)

Note: rebasing produces a totally new revision history, even if you only choose “reword” so be careful if you do it after *pushing* your project somewhere, because any commits people make to your old history will get uh... lost, unless you manually cherry pick them. Try to anticipate whether your project managers will be anal (they *always* are) and run your `git rebase -i $commit~1` before pushing your changes. That actually works out pretty well, because it’s easier to think of a bunch of convincing sounding bullshit commit messages in a row, and because as you specifically see the changes in `git show` you will find it easier to write a message about what changed.

Otherwise, leave the “auto” messages in there, and every time you finish implementing a feature, go `git commit --allow-empty -a -m "recombobulated the frobnicators"` and your revision history will be completely clear to anyone who understands how revisioning works. Don’t leave your messages as “tags” because those don’t go into the revision history, so they won’t appear in the git log.
